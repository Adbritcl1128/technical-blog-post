I have been a student at the Iron Yard coding boot camp for 7 weeks now and one of the most enlightening moments I have had was when I finally got my head around the fetch function.  This is not just because of the usefulness of what it does at its core, which is to basically retrieve and move data as well as manipulate the format of it, but rather because it is a fantastic demonstration of how a number of the most fundamental pieces of the Javascript language work.  
     Fetch is the tool Javascript gives us to connect to data sets, which often times live within API’s.   The word fetch followed by the URL containing the data you want to retrieve initiates a request to the URL and returns a promise.  The code below is a very simplified fetch request and the same work can be done with less specific code, but it is important and helpful to understand the mechanics of it first.  For instance, technically fetch does not need to be a variable as it is below, but it was super helpful for me to think of it as one while learning.
   The first line of the code below returns a promise.  It took me forever to truly understand what that meant until I started to comprehend exactly what was going on at the simplest level.  When the computer recognizes that you have written the word fetch as well as an API URL in parentheses, it is as if it you have just told the computer, “Hey, expect a set of steps to follow that adhere to a very specific structure.”  On the second line in the example below, the promise, which was returned by the fetch function, is being acted upon starting with the word then.  When the computer sees that you have written the word then following the promise returned by the fetch function, the next piece in the “structure” of steps is to enter a function, which takes an argument called response.   It is important to understand that after that function is written, we can the access all of the information about what came back from our designated API (A number generally between 200 and 400 that represents the different status’s of data at a given time,) by simply logging out the word response (.) status.  
     The next part of the code is saying use the response from our argument parentheses in the first function and turn in into JSON formatted data.  The callback function on the (.) then promise is used to actually produce the data for us, JSON formatted        

let thePromise = fetch('https://randomuser.me/api/');  thePromise.then(function getTheResponse(response) {   console.log('The HTTP status is:', response.status);    response.json().then(function getTheData(data) {     console.log('The data sent back is:', data);   });  });

     The code pictured below is doing precisely the same thing as the code above the only difference being that the code below is handling all possible error scenarios that could happen during the interaction with the server and fetching of our data.  The only thing that is new here code wise is the catch function.  This acts precisely as the (.) then or (.) json function does in the sense that it takes a callback function, but instead the purpose of this function is to simply handle errors via the callback function they take in as opposed to provide a response status or newly json formatted data.  


 fetch('https://randomuser.me/api/')   .then(function getTheResponse(response) {     if (response.status !== 200) {       console.error('Uh oh, the request failed with status code:', response.status);       return; // make sure we quit this chain!     }      response.json()       .then(function getTheData(data) {         console.log('The data sent back is:', data);       })       .catch(function handleParseError(err) {         console.error('Uh oh, the data coming back from the server was not json.');       });    })   .catch(function handleErrors(err) {     console.error('Oops, the browser failed to send the request:', err);   });
